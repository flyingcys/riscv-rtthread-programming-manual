<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>6、移植 &mdash; RISC-V RT-Thread 编程指南 0.0.1 文档</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/translations.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="prev" title="5、线程切换" href="5.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            RISC-V RT-Thread 编程指南
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <p class="caption" role="heading"><span class="caption-text">目录</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="1.html">1、RISC-V 概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="2.html">2、启动</a></li>
<li class="toctree-l1"><a class="reference internal" href="3.html">3、异常与中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="4.html">4、驱动框架与适配</a></li>
<li class="toctree-l1"><a class="reference internal" href="5.html">5、线程切换</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">6、移植</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">6.1、相关寄存器</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#mie">MIE</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mtvec">MTVEC</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#freertos">6.2、FreeRTOS 工程梳理</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">单独编译 FreeRTOS工程</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">启动文件</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#bsp">6.3、移植第一阶段：bsp工程创建与编译</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id5">bsp 目录</a></li>
<li class="toctree-l3"><a class="reference internal" href="#drivers">drivers 目录</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">串口驱动</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">堆栈配置</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id8">6.4、移植第二阶段：文件打包</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id9">6.5、移植第三阶段：中断</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id10">中断初始化</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">中断配置</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rt-thread">RT-Thread 中断配置</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">外部中断管理</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id13">硬件定时器</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id14">6.6、移植第四阶段：线程切换</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">RISC-V RT-Thread 编程指南</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">6、移植</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/zh_CN/6.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>6、移植<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h1>
<p>milk-v duo 中的小核是比较特殊的 RISC-V 64 位 无 MMU 的平头哥 C906，猜测应该是为了节省成本将 MMU 裁剪掉了。本文通过循序渐进的方式一步一步完成适配 RT-Thread.。</p>
<section id="id2">
<h2>6.1、相关寄存器<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h2>
<section id="mie">
<h3>MIE<a class="headerlink" href="#mie" title="此标题的永久链接"></a></h3>
<p>机器模式中断使能控制寄存器（MIE）用于控制不同中断类型的使能和屏蔽。该寄存器的位长是 64 位，寄存器的读写权限是机器模式可读写，即非机器模式访问都会导致非法指令异常。</p>
<p><img alt="MIE" src="img/risc-v/risc-v/RV64/MIE.png" /></p>
<p>SSIE-超级用户模式软件中断使能位：
• 当 SEIE 为 0 时，超级用户模式软件外部中断未始能。
• 当 SEIE 为 1 时，超级用户模式软件外部中断被始能。
该位会被 reset 置为 1’ b0。</p>
<p>MSIE-机器模式软件中断使能位：
• 当 MSIE 为 0 时，机器模式软件中断未始能。
• 当 MSIE 为 1 时，机器模式软件中断被始能。
该位会被 reset 置为 1’ b0。</p>
<p>STIE-超级用户模式定时器中断使能位：
• 当 STIE 为 0 时，超级用户模式定时器中断未始能。
• 当 STIE 为 1 时，超级用户模式定时器中断被始能。
该位会被 reset 置为 1’ b0。</p>
<p>MTIE-机器模式定时器中断使能位：
• 当 MTIE 为 0 时，机器模式定时器中断未始能。
• 当 MTIE 为 1 时，机器模式定时器中断被始能。
该位会被 reset 置为 1’ b0。</p>
<p>SEIE-超级用户模式外部中断使能位：
• 当 SEIE 为 0 时，超级用户模式外部中断未始能。
• 当 SEIE 为 1 时，超级用户模式外部中断被始能。
该位会被 reset 置为 1’ b0。</p>
<p>MEIE-机器模式外部中断使能位：
• 当 MEIE 为 0 时，机器模式外部中断未始能。
• 当 MEIE 为 1 时，机器模式外部中断被始能。
该位会被 reset 置为 1’ b0。</p>
<p>MOIE-性能监测单元机器模式事件计数器溢出中断使能位：
• 当 MOIE 为 0 时，机器模式计数器溢出中断未始能。
• 当 MOIE 为 1 时，机器模式计数器溢出中断被始能。
该位会被 reset 置为 1’ b0。</p>
</section>
<section id="mtvec">
<h3>MTVEC<a class="headerlink" href="#mtvec" title="此标题的永久链接"></a></h3>
<p>机器模式向量基址寄存器（MTVEC）用于配置异常服务程序的入口地址。</p>
<p><img alt="MTVEC" src="img/risc-v/risc-v/RV64/MTVEC.png" /></p>
<ol class="simple">
<li><p>BASE-向量基址位：
向量基址位指示了异常服务程序入口地址的高 37 位，将此基址拼接 2’ b00 即可得到异常服务程序入口地址。
该位会被 reset 置为 62’ h0。</p></li>
<li><p>MODE-向量入口模式位：</p></li>
</ol>
<ul class="simple">
<li><p>当 MODE[1:0] 为 2’ b00 时，异常和中断都统一使用 BASE 地址作为异常入口地址。</p></li>
<li><p>当 MODE[1:0] 为 2’ b01 时，异常使用 BASE 地址作为入口地址，中断使用 BASE + 4*Exception Code。
该位会被 reset 置为 2’ b00。</p></li>
</ul>
</section>
</section>
<section id="freertos">
<h2>6.2、FreeRTOS 工程梳理<a class="headerlink" href="#freertos" title="此标题的永久链接"></a></h2>
<p>通过 <a class="reference external" href="#">milk-v duo 编译流程二之小核 FreeRTOS 编译</a> 一文可以详细了解编译及最终 bin 文件生成过程。</p>
<section id="id3">
<h3>单独编译 FreeRTOS工程<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h3>
<p>在 bash 下运行：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">export</span><span class="w"> </span><span class="nv">MILKV_BOARD</span><span class="o">=</span>milkv-duo
$<span class="w"> </span><span class="nb">source</span><span class="w"> </span>milkv/boardconfig-milkv-duo.sh
$<span class="w"> </span><span class="nb">source</span><span class="w"> </span>build/milkvsetup.sh
$<span class="w"> </span>defconfig<span class="w"> </span>cv1800b_milkv_duo_sd
$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>/home/share/samba/risc-v/duo-buildroot-sdk/freertos/cvitek<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>./build_cv180x.sh
</pre></div>
</div>
</section>
<section id="id4">
<h3>启动文件<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h3>
<ol class="simple">
<li><p>找到 ld 文件：
通过 -T duo-buildroot-sdk/freertos/cvitek/scripts/cv180x_lscript.ld 找到链接脚本。</p></li>
<li><p>通过 ld 文件定位入口函数及对应的文件：启动文件为 freertos/cvitek/arch/riscv64/src/start.S</p></li>
</ol>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*ENTRY(_vector_table)*/</span>
<span class="n">ENTRY</span><span class="p">(</span><span class="n">_start</span><span class="p">)</span>
</pre></div>
</div>
<ol class="simple">
<li><p>编译参数：
编译参数位于 freertos/cvitek/scripts/toolchain-riscv64-elf.cmake 文件。</p></li>
</ol>
</section>
</section>
<section id="bsp">
<h2>6.3、移植第一阶段：bsp工程创建与编译<a class="headerlink" href="#bsp" title="此标题的永久链接"></a></h2>
<p>第一阶段目标：可以正常编译 RT-Thread，生成 rtthread.bin 后通过脚本合并生成可运行的 bin 文件。</p>
<section id="id5">
<h3>bsp 目录<a class="headerlink" href="#id5" title="此标题的永久链接"></a></h3>
<p>包括：</p>
<ol class="simple">
<li><p>链接脚本：
复制 duo-buildroot-sdk/freertos/cvitek/scripts/cv180x_lscript.ld 及 build/output/cv1800b_milkv_duo_sd/cvi_board_memmap.ld。</p></li>
<li><p>添加 Kconfig 文件:
由于 cv 1800b 小核是 c906-nommu，在 Kconfig 文件中必须添加以下配置：</p></li>
</ol>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>config<span class="w"> </span>BSP_USING_CV1800B
<span class="w">    </span>bool
<span class="w">    </span><span class="k">select</span><span class="w"> </span>ARCH_RISCV64
<span class="w">    </span><span class="k">select</span><span class="w"> </span>RT_USING_COMPONENTS_INIT
<span class="w">    </span><span class="k">select</span><span class="w"> </span>RT_USING_USER_MAIN
<span class="w">    </span>default<span class="w"> </span>y
</pre></div>
</div>
<ol class="simple">
<li><p>添加 scons 编译文件 SConscript 和 SConstruct。</p></li>
<li><p>建立 libraries 目录，复制 freertos/cvitek/arch/riscv64 目录，并修改 start.S 文件中硬件初始化完成后跳转到 C 的函数为 <code class="docutils literal notranslate"><span class="pre">entry</span></code>。</p></li>
<li><p>修改 rtconfig.py 中的编译参数，相关参数参考 freertos/cvitek/scripts/toolchain-riscv64-elf.cmake 文件。</p></li>
<li><p>添加 main.c 文件，不然编译要报错。
添加 main 函数</p></li>
</ol>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;rtthread.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">rt_kprintf</span><span class="p">(</span><span class="s">&quot;Hello, RISC-V!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="drivers">
<h3>drivers 目录<a class="headerlink" href="#drivers" title="此标题的永久链接"></a></h3>
<ol class="simple">
<li><p>创建 drivers 目录，添加 board.c 、board.h，在 board.c 中实现 <code class="docutils literal notranslate"><span class="pre">rt_hw_board_init()</span></code> 函数，该文件在 <code class="docutils literal notranslate"><span class="pre">rtthread_startup()</span></code> 函数中被调用。并需在该函数中先实现串口初始化及 <code class="docutils literal notranslate"><span class="pre">rt_console</span></code> 设备注册，用于日志输出。</p></li>
</ol>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">rt_hw_board_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef RT_USING_SERIAL</span>
<span class="w">    </span><span class="n">rt_hw_uart_init</span><span class="p">();</span>
<span class="cp">#endif</span>

<span class="w">    </span><span class="cm">/* Set the shell console output device */</span>
<span class="cp">#if defined(RT_USING_CONSOLE) &amp;&amp; defined(RT_USING_DEVICE)</span>
<span class="w">    </span><span class="n">rt_console_set_device</span><span class="p">(</span><span class="n">RT_CONSOLE_DEVICE_NAME</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef RT_USING_COMPONENTS_INIT</span>
<span class="w">    </span><span class="n">rt_components_board_init</span><span class="p">();</span>
<span class="cp">#endif      </span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id6">
<h3>串口驱动<a class="headerlink" href="#id6" title="此标题的永久链接"></a></h3>
<ol class="simple">
<li><p>串口驱动适配</p></li>
<li><p>进入 menuconfig，配置 console 串口设备。在 RT-Thread Kernel 菜单下配置。</p></li>
</ol>
<ul class="simple">
<li><p>选中 <code class="docutils literal notranslate"><span class="pre">Using</span> <span class="pre">console</span> <span class="pre">for</span> <span class="pre">rt_kprintf</span></code>，默认已选中。</p></li>
<li><p>将 <code class="docutils literal notranslate"><span class="pre">the</span> <span class="pre">device</span> <span class="pre">name</span> <span class="pre">for</span> <span class="pre">console</span></code> 名字修改为与上诉驱动名一致，当前配置为 <code class="docutils literal notranslate"><span class="pre">uart0</span></code>。</p></li>
<li><p>可以修改 <code class="docutils literal notranslate"><span class="pre">the</span> <span class="pre">buffer</span> <span class="pre">size</span> <span class="pre">for</span> <span class="pre">console</span> <span class="pre">log</span> <span class="pre">printf</span></code> 值，默认为 <code class="docutils literal notranslate"><span class="pre">128</span></code>，可能会影响某些特别长的打印正常显示，可根据当前芯片内存情况修改为 <code class="docutils literal notranslate"><span class="pre">256</span></code> 或 <code class="docutils literal notranslate"><span class="pre">512</span></code>。</p></li>
</ul>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>scons<span class="w"> </span>--menuconfig
<span class="w">    </span>RT-Thread<span class="w"> </span>Kernel<span class="w">  </span>---&gt;
<span class="w">        </span><span class="o">[</span>*<span class="o">]</span><span class="w"> </span>Using<span class="w"> </span>console<span class="w"> </span><span class="k">for</span><span class="w"> </span>rt_kprintf
<span class="w">        </span><span class="o">(</span><span class="m">512</span><span class="o">)</span><span class="w"> </span>the<span class="w"> </span>buffer<span class="w"> </span>size<span class="w"> </span><span class="k">for</span><span class="w"> </span>console<span class="w"> </span>log<span class="w"> </span><span class="nb">printf</span>
<span class="w">        </span><span class="o">(</span>uart0<span class="o">)</span><span class="w"> </span>the<span class="w"> </span>device<span class="w"> </span>name<span class="w"> </span><span class="k">for</span><span class="w"> </span>console<span class="w"> </span>
</pre></div>
</div>
</section>
<section id="id7">
<h3>堆栈配置<a class="headerlink" href="#id7" title="此标题的永久链接"></a></h3>
<ol class="simple">
<li><p>查看 ld 文件，获取到内存 section 分布情况。</p></li>
</ol>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">MEMORY</span>
<span class="p">{</span>
<span class="w">   </span><span class="nl">psu_ddr_0_MEM_0</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">ORIGIN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CVIMMAP_FREERTOS_ADDR</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">LENGTH</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CVIMMAP_FREERTOS_SIZE</span>
<span class="p">}</span>
</pre></div>
</div>
<p>CVIMMAP_FREERTOS_ADDR 和 CVIMMAP_FREERTOS_SIZE 定义在 cvi_board_memmap.ld 文件中，该文件在原厂 SDK 是自动生成的，这里我们用的是自动生成完成后的文件。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">CVIMMAP_FREERTOS_ADDR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x83f40000</span><span class="p">;</span>
<span class="n">CVIMMAP_FREERTOS_RESERVED_ION_SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0</span><span class="p">;</span>
<span class="n">CVIMMAP_FREERTOS_SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xc0000</span><span class="p">;</span>
</pre></div>
</div>
<p>代码和数据都放在 RAM 上运行， 地址为 <code class="docutils literal notranslate"><span class="pre">0x83f40000:</span> <span class="pre">0x84000000</span></code> 总共 <code class="docutils literal notranslate"><span class="pre">0xc0000</span></code> 字节。</p>
<ol class="simple">
<li><p>stack 设置</p></li>
</ol>
<p>修改 ld 文件，添加 __rt_rvstack 为栈顶地址。</p>
<ol class="simple">
<li><p>heap 设置
我们将 程序运行空间、全局变量、栈空间等之外所有剩余的空间都作为 heap 使用，并会根据程序/数据的大小自动动态调整。</p></li>
</ol>
<ul class="simple">
<li><p>修改 ld 文件。原 ld 文件中 heap 定义在 stack 前，FreeRTOS 的 heap 是通过全局数据来定义的属于 .bss 段，所以定义没有问题。当前适配需要做一定的修改，将 stack 放在 heap 前面，并将所有的剩余空间都作为 heap 使用。</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Generate Stack and Heap definitions */</span>
<span class="p">.</span><span class="n">stack</span><span class="w"> </span><span class="p">(</span><span class="n">NOLOAD</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="p">.</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ALIGN</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
<span class="w">   </span><span class="n">_stack_end_end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.;</span>
<span class="w">   </span><span class="p">.</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">_STACK_SIZE</span><span class="p">;</span>
<span class="w">   </span><span class="n">_stack_top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.;</span>
<span class="w">  </span><span class="n">__rt_rvstack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.;</span><span class="w"> </span>
<span class="p">}</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">psu_ddr_0_MEM_0</span>

<span class="p">.</span><span class="n">heap</span><span class="w"> </span><span class="p">(</span><span class="n">NOLOAD</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="p">.</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ALIGN</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
<span class="w">   </span><span class="n">_heap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.;</span>
<span class="w">   </span><span class="n">HeapBase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.;</span>
<span class="w">   </span><span class="n">_heap_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.;</span>
<span class="w">   </span><span class="o">*</span><span class="p">(.</span><span class="n">heap</span><span class="o">*</span><span class="p">)</span>
<span class="w">   </span><span class="cm">/*. += _HEAP_SIZE;*/</span>
<span class="w">   </span><span class="cm">/*_heap_size = _HEAP_SIZE; */</span>
<span class="w">   </span><span class="n">_heap_end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.;</span>
<span class="w">   </span><span class="n">HeapLimit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.;</span>
<span class="p">}</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">psu_ddr_0_MEM_0</span>

<span class="n">HeapLimit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ORIGIN</span><span class="p">(</span><span class="n">psu_ddr_0_MEM_0</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">LENGTH</span><span class="p">(</span><span class="n">psu_ddr_0_MEM_0</span><span class="p">);</span>
<span class="n">_end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>修改  board.h，添加 heap 的起、始地址。</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="n">rt_uint8_t</span><span class="w"> </span><span class="n">HeapBase</span><span class="p">;</span>
<span class="k">extern</span><span class="w"> </span><span class="n">rt_uint8_t</span><span class="w"> </span><span class="n">HeapLimit</span><span class="p">;</span>

<span class="cp">#define RT_HW_HEAP_BEGIN    (void *)&amp;HeapBase</span>
<span class="cp">#define RT_HW_HEAP_END      (void *)&amp;HeapLimit</span>
</pre></div>
</div>
<ul class="simple">
<li><p>修改 board.c
在 <code class="docutils literal notranslate"><span class="pre">rt_hw_board_init()</span></code> 函数最前面加入 heap 初始化代码。</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef RT_USING_HEAP</span>
<span class="w">    </span><span class="cm">/* initialize memory system */</span>
<span class="w">    </span><span class="n">rt_system_heap_init</span><span class="p">(</span><span class="n">RT_HW_HEAP_BEGIN</span><span class="p">,</span><span class="w"> </span><span class="n">RT_HW_HEAP_END</span><span class="p">);</span>
<span class="cp">#endif</span>
</pre></div>
</div>
</section>
</section>
<section id="id8">
<h2>6.4、移植第二阶段：文件打包<a class="headerlink" href="#id8" title="此标题的永久链接"></a></h2>
<p>第二阶段目标：将第一阶段生成的 bin 文件与其他相关的文件合并，生成芯片需要的相关文件后可以正常启动运行，可以在启动后显示 rt-thread 启动 LOG。</p>
<p>根据前文分析，cv1800b 小核生成的文件是打包在 fip.bin 文件内的，fip.bin 由 BL2、opensbi、uboot、小核 bin 文件等工作合并而成。将需要的相关文件和打包脚本整合进入 RT-Thread bsp 工程，打包脚本命名为 combine.sh。</p>
<p>将上诉生成的 rtthread.bin 文件通过 combine.sh 脚本和 BL2、opensbi、uboot 合并生成 fip.bin，更新至 SD 卡，即可正常运行。</p>
<p>完成以上工作后，可以在串口中看到如下启动日志：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>C.SCS/0/0.WD.URPL.SDI/25000000/6000000.BS/SD.PS.SD/0x0/0x1000/0x1000/0.PE.BS.SD/0x1000/0xba00/0xba00/0.BE.J.
FSBL<span class="w"> </span>Jb28g9:gd1d59d9af-dirty:2023-12-18T11:59:36+08:00
<span class="nv">st_on_reason</span><span class="o">=</span><span class="m">4090003</span>
<span class="nv">st_off_reason</span><span class="o">=</span><span class="m">0</span>
P2S/0x1000/0x3bc0da00.
SD/0xca00/0x1000/0x1000/0.P2E.
DPS/0xda00/0x2000.
SD/0xda00/0x2000/0x2000/0.DPE.
DDR<span class="w"> </span>init.
ddr_param<span class="o">[</span><span class="m">0</span><span class="o">]=</span>0x78075562.
<span class="nv">pkg_type</span><span class="o">=</span><span class="m">3</span>
D3_1_4
DDR2-512M-QFN68
DDR<span class="w"> </span>BIST<span class="w"> </span>PASS
PLLS.
PLLE.
C2S/0xfa00/0x83f40000/0x6e00.
SD/0xfa00/0x6e00/0x6e00/0.RSC.
C2E.
MS/0x16800/0x80000000/0x1b000.

<span class="w"> </span><span class="se">\ </span><span class="p">|</span><span class="w"> </span>/
-<span class="w"> </span>RT<span class="w"> </span>-<span class="w">     </span>Thread<span class="w"> </span>Operating<span class="w"> </span>System
<span class="w"> </span>/<span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="se">\ </span><span class="w">    </span><span class="m">5</span>.1.0<span class="w"> </span>build<span class="w"> </span>Dec<span class="w"> </span><span class="m">18</span><span class="w"> </span><span class="m">2023</span><span class="w"> </span><span class="m">17</span>:29:19
<span class="w"> </span><span class="m">2006</span><span class="w"> </span>-<span class="w"> </span><span class="m">2022</span><span class="w"> </span>Copyright<span class="w"> </span>by<span class="w"> </span>RT-Thread<span class="w"> </span>team
</pre></div>
</div>
<p>RT-Thread 已经启动起来了，但是由于对中断相关工作进行配置处理，所以调度器不能正常运行，其实是处于裸机工作状态。</p>
</section>
<section id="id9">
<h2>6.5、移植第三阶段：中断<a class="headerlink" href="#id9" title="此标题的永久链接"></a></h2>
<p>我们知道操作系统是需要靠硬件定时器定时中断做任务调度的，所以中断是移植 RT-Thread 最重要的工作之一。</p>
<section id="id10">
<h3>中断初始化<a class="headerlink" href="#id10" title="此标题的永久链接"></a></h3>
<p>在 start.S 文件中，在启动函数 <code class="docutils literal notranslate"><span class="pre">_start</span></code> 中通过配置 MIE 寄存器使能相关中断。</p>
<div class="highlight-s notranslate"><div class="highlight"><pre><span></span><span class="w">	</span><span class="o">//</span><span class="w"> </span><span class="n">enable</span><span class="w"> </span><span class="n">interrupt</span>
<span class="w">	</span><span class="n">li</span><span class="w"> </span><span class="n">x3</span><span class="p">,</span><span class="w"> </span><span class="mh">0x880</span>
<span class="w">	</span><span class="n">csrw</span><span class="w"> </span><span class="n">mie</span><span class="p">,</span><span class="w"> </span><span class="n">x3</span>
</pre></div>
</div>
<p>其中：</p>
<ul class="simple">
<li><p>MEIE = 1：使能机器模式外部中断使能位</p></li>
<li><p>MTIE = 1：使能机器模式定时器中断</p></li>
</ul>
<p>在 RT-Thread 中 MEIE 和 MTIE 中断使能均在对应模块中使能，这部分代码可以注释。</p>
</section>
<section id="id11">
<h3>中断配置<a class="headerlink" href="#id11" title="此标题的永久链接"></a></h3>
<p>在 FreeRTOS 中，中断函数配置不是在启动阶段配置，是在 freertos/Source/portable/GCC/RISC-V/portASM.S 文件 <code class="docutils literal notranslate"><span class="pre">xPortStartFirstTask</span></code> 函数中进行设置。</p>
<div class="highlight-s notranslate"><div class="highlight"><pre><span></span><span class="n">.align</span><span class="w"> </span><span class="m">8</span>
<span class="n">.func</span>
<span class="n">freertos_risc_v_trap_handler</span><span class="o">:</span>

<span class="w">    </span><span class="kc">...</span>

<span class="w">    </span><span class="n">mret</span>

<span class="n">.align</span><span class="w"> </span><span class="m">8</span>
<span class="n">.func</span>
<span class="n">xPortStartFirstTask</span><span class="o">:</span>
<span class="w">	</span><span class="n">la</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">freertos_risc_v_trap_handler</span>
<span class="w">	</span><span class="n">csrw</span><span class="w"> </span><span class="n">mtvec</span><span class="p">,</span><span class="w"> </span><span class="n">t0</span>

<span class="w">    </span><span class="kc">...</span>

<span class="w">    </span><span class="n">ret</span>
</pre></div>
</div>
<p>对以上部分代码进行解读如下：</p>
<ol class="simple">
<li><p>对齐伪指令.align
用法：<code class="docutils literal notranslate"><span class="pre">.align</span> <span class="pre">integer</span></code></p></li>
</ol>
<p>.align 伪操作用于将当前PC地址推进到 “2的integer次方个字节” 对齐的位置，如 <code class="docutils literal notranslate"><span class="pre">.align</span> <span class="pre">3</span></code> 即表示将当前PC地址推进到 8 个字节对齐的位置处。上面代码中使用了
<code class="docutils literal notranslate"><span class="pre">.align</span> <span class="pre">8</span></code> 即为 256 字节对齐。</p>
<ol class="simple">
<li></li>
</ol>
<p>原厂 FreeRTOS 工程中使用模式位 MODE = 0，异常和中断统一使用了 <code class="docutils literal notranslate"><span class="pre">freertos_risc_v_trap_handler</span></code>  函数，在该函数中判断是异常还是中断，并做进一步处理。</p>
<ol class="simple">
<li><p>csrw 指令是一条伪指令，用于将通用寄存器的值写入 CSR 寄存器。</p></li>
</ol>
</section>
<section id="rt-thread">
<h3>RT-Thread 中断配置<a class="headerlink" href="#rt-thread" title="此标题的永久链接"></a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">_start</span></code> 函数中加入：</p>
<div class="highlight-s notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="n">la</span><span class="w">      </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span>__<span class="n">Vectors</span>
<span class="w">    </span><span class="n">li</span><span class="w">	    </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="mh">0x1</span>
<span class="w">    </span><span class="n">or</span><span class="w">	    </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">a0</span><span class="p">,</span><span class="n">a1</span>
<span class="w">    </span><span class="n">csrw</span><span class="w">    </span><span class="n">mtvec</span><span class="p">,</span><span class="w"> </span><span class="n">a0</span>
</pre></div>
</div>
<p>将 mtvec 的 MODE 设置位1，并将 __Vectors 作为</p>
<p>在 vectors.S 中加入 <code class="docutils literal notranslate"><span class="pre">__Vector</span></code> 函数：</p>
<div class="highlight-s notranslate"><div class="highlight"><pre><span></span><span class="n">.section</span><span class="w"> </span><span class="n">.text</span>
<span class="w">    </span><span class="n">.align</span><span class="w">  </span><span class="m">6</span>
<span class="w">    </span><span class="n">.globl</span><span class="w">  </span>__<span class="n">Vectors</span>
<span class="w">    </span><span class="n">.type</span><span class="w">   </span>__<span class="n">Vectors</span><span class="p">,</span><span class="w"> </span><span class="o">@</span><span class="n">object</span>
__<span class="n">Vectors</span><span class="o">:</span>
<span class="w">    </span><span class="n">j</span><span class="w">   </span><span class="n">Default_Handler</span><span class="w">				</span><span class="o">/*</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="o">*/</span>
<span class="w">    </span><span class="n">j</span><span class="w">   </span><span class="n">Stspend_Handler</span><span class="w">			</span><span class="o">/*</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>超级用户模式软件中断<span class="w"> </span><span class="o">*/</span>
<span class="w">    </span><span class="n">j</span><span class="w">   </span><span class="n">Default_Handler</span><span class="w">				</span><span class="o">/*</span><span class="w"> </span><span class="m">2</span><span class="w"> </span>保留<span class="w"> </span><span class="o">*/</span>
<span class="w">    </span><span class="n">j</span><span class="w">   </span><span class="n">Mtspend_Handler</span><span class="w">			</span><span class="o">/*</span><span class="w"> </span><span class="m">3</span><span class="w"> </span>机器模式软件中断<span class="w"> </span><span class="o">*/</span>
<span class="w">    </span><span class="n">j</span><span class="w">   </span><span class="n">Default_Handler</span><span class="w">				</span><span class="o">/*</span><span class="w"> </span><span class="m">4</span><span class="w"> </span>未实现<span class="w"> </span><span class="o">*/</span>
<span class="w">    </span><span class="n">j</span><span class="w">   </span><span class="n">Scoret_Handler</span><span class="w">			</span><span class="o">/*</span><span class="w"> </span><span class="m">5</span><span class="w"> </span>超级用户模式定时器中断<span class="w"> </span><span class="o">*/</span>
<span class="w">    </span><span class="n">j</span><span class="w">   </span><span class="n">Default_Handler</span><span class="w">				</span><span class="o">/*</span><span class="w"> </span><span class="m">6</span><span class="w"> </span>保留<span class="w"> </span><span class="o">*/</span>
<span class="w">    </span><span class="n">j</span><span class="w">   </span><span class="n">Mcoret_Handler</span><span class="w">			</span><span class="o">/*</span><span class="w"> </span><span class="m">7</span><span class="w"> </span>机器模式定时器中断<span class="w"> </span><span class="o">*/</span>
<span class="w">    </span><span class="n">j</span><span class="w">   </span><span class="n">Default_Handler</span><span class="w">				</span><span class="o">/*</span><span class="w"> </span><span class="m">8</span><span class="w"> </span>未实现<span class="w"> </span><span class="o">*/</span>
<span class="w">    </span><span class="n">j</span><span class="w">   </span><span class="n">Sirq_Handler</span><span class="w">			</span><span class="o">/*</span><span class="w"> </span><span class="m">9</span><span class="w"> </span>超级用户模式外部中断<span class="w"> </span><span class="o">*/</span>
<span class="w">    </span><span class="n">j</span><span class="w">   </span><span class="n">Default_Handler</span><span class="w">				</span><span class="o">/*</span><span class="w"> </span><span class="m">10</span><span class="w"> </span>保留<span class="w"> </span><span class="o">*/</span>
<span class="w">    </span><span class="n">j</span><span class="w">   </span><span class="n">Mirq_Handler</span><span class="w">			</span><span class="o">/*</span><span class="w"> </span><span class="m">11</span><span class="w"> </span>机器模式外部中断<span class="w"> </span><span class="o">*/</span>
<span class="w">    </span><span class="n">j</span><span class="w">   </span><span class="n">Default_Handler</span><span class="w">				</span><span class="o">/*</span><span class="w"> </span><span class="m">12</span><span class="w"> </span>保留<span class="w"> </span><span class="o">*/</span>
<span class="w">    </span><span class="n">j</span><span class="w">   </span><span class="n">Default_Handler</span><span class="w">				</span><span class="o">/*</span><span class="w"> </span><span class="m">13</span><span class="w"> </span>保留<span class="w"> </span><span class="o">*/</span>
<span class="w">    </span><span class="n">j</span><span class="w">   </span><span class="n">Default_Handler</span><span class="w">				</span><span class="o">/*</span><span class="w"> </span><span class="m">14</span><span class="w"> </span>保留<span class="w"> </span><span class="o">*/</span>
<span class="w">    </span><span class="n">j</span><span class="w">   </span><span class="n">Default_Handler</span><span class="w">				</span><span class="o">/*</span><span class="w"> </span><span class="m">15</span><span class="w"> </span>保留<span class="w"> </span><span class="o">*/</span>
</pre></div>
</div>
<p>上面提到小核是 C906-NOMMU，所以只能工作在机器模式下，超级用户模式下的中断都作为异常处理。
涉及到的中断有 3 种：</p>
<ul class="simple">
<li><p>定时器中断</p></li>
<li><p>外部中断</p></li>
<li><p>软件中断</p></li>
</ul>
</section>
<section id="id12">
<h3>外部中断管理<a class="headerlink" href="#id12" title="此标题的永久链接"></a></h3>
<p>原厂 SDK 未提供外部中断管理想的接口，使用 RT-Thread 自带的外部中断管理接口。
包括：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">rt_hw_interrupt_init</span><span class="p">()</span>
<span class="n">rt_hw_interrupt_install</span><span class="p">()</span>
<span class="n">rt_hw_interrupt_mask</span><span class="p">()</span>
<span class="n">rt_hw_interrupt_umask</span><span class="p">()</span>
</pre></div>
</div>
<p>RT-Thread 所有中断处理函数都需要调用 <code class="docutils literal notranslate"><span class="pre">rt_interrupt_enter();</span></code> 通知系统进入中断，调用 <code class="docutils literal notranslate"><span class="pre">rt_interrupt_leave();</span></code> 通知系统离开中断。</p>
</section>
<section id="id13">
<h3>硬件定时器<a class="headerlink" href="#id13" title="此标题的永久链接"></a></h3>
<p>按照 RISC-V 标准定义，在系统中需要实现一个 64 位的系统定时器 MTIME，定时器中断属于处理器核局部中断 CLINT 模块。</p>
<p>该系统定时器有一组 64 位的机器模式定时器比价寄存器 （MTIMECMPH、MTIMECMPL），通过比较系统定时器的当前值（MTIME）与比较寄存器（MTIMECMPH[31:0]、MTIMECMPL[31:0]）的值来确定是否产生定时器中断。</p>
<ul class="simple">
<li><p>当系统定时器的值小于等于（MTIMECMPH[31:0]、MTIMECMPL[31:0]）的值不产生中断。</p></li>
<li><p>当系统定时器的值大于（MTIMECMPH[31:0]、MTIMECMPL[31:0]）的值时 CLINT 产生对应的定时器中断。</p></li>
</ul>
<p>软件通过改写 MTIMECMP 的值来清除对应的定时器中断。</p>
<p>MTIMECMPH/MTIMECMPL：机器模式定时器中断比较值寄存器高位/低位
该寄存器存储了定时器比较值。</p>
<ul class="simple">
<li><p>MTIMECMPH：定时器比较值高 32 位；</p></li>
<li><p>MTIMECMPL：定时器比较值低 32 位</p></li>
</ul>
<p><img alt="MTIMECMP" src="img/risc-v/risc-v/interrupt/MTIMECMP.png" /></p>
<ol class="simple">
<li><p>硬件定时器中断函数处理</p></li>
</ol>
<ul class="simple">
<li><p>初始化</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">rt_hw_tick_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* Clear the Machine-Timer bit in MIE */</span>
<span class="w">    </span><span class="n">clear_csr</span><span class="p">(</span><span class="n">mie</span><span class="p">,</span><span class="w"> </span><span class="n">MIP_MTIP</span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* Enable the Machine-Timer bit in MIE */</span>
<span class="w">    </span><span class="n">set_csr</span><span class="p">(</span><span class="n">mie</span><span class="p">,</span><span class="w"> </span><span class="n">MIP_MTIP</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>主要完成以下工作：
- 关中断
- 设置 mtimer 值
- 开中断</p>
<ul class="simple">
<li><p>中断函数处理
硬件定时器中断函数处理以下内容：</p>
<ul>
<li><p>调用 <code class="docutils literal notranslate"><span class="pre">rt_tick_increase()</span></code></p></li>
<li><p>重新设置 mtimer 值</p></li>
</ul>
</li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</section>
</section>
<section id="id14">
<h2>6.6、移植第四阶段：线程切换<a class="headerlink" href="#id14" title="此标题的永久链接"></a></h2>
<p>[todo]</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="5.html" class="btn btn-neutral float-left" title="5、线程切换" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2024, 燕十三.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>